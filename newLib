-- =================================================================
--      最终版：包含加载器的一体化“物品自动拾取器”脚本
--          执行此脚本将自动加载 Night UI 并创建自定义模块
-- =================================================================

-- 步骤 1: 定义我们的自定义模块创建函数
-- 我们将所有自定义逻辑都放在这个函数里，方便之后调用
local function createOurCustomModule()
    -- 短暂等待，确保 Night UI 的所有组件都已完全准备就绪
    task.wait(0.5)

    -- 再次检查 Night 环境是否正确加载
    if not (getgenv().Night and getgenv().Night.Tabs and getgenv().Night.Assets) then
        warn("Night UI 未能正确初始化。自定义模块创建已中止。")
        return
    end

    -- 初始化 Night 变量和常用服务
    local Night = getgenv().Night
    local Functions = Night.Assets.Functions
    local Tabs = Night.Tabs.Tabs
    local plrs = Functions.cloneref(game:GetService("Players"))
    local ws = Functions.cloneref(game:GetService("Workspace"))
    local tweenService = Functions.cloneref(game:GetService("TweenService"))
    local lplr = plrs.LocalPlayer

    -- 创建数据表来存储模块的所有状态
    local ModuleData = {
        Toggle = nil,
        ItemNames = "Cash,Coin,Gem",
        CollectionRadius = 50,
        CollectionMethod = "吸附物品",
        NotifyOnCollect = true,
        IsEnabled = false
    }

    -- 在 "Utility" 标签页下创建我们的新模块
    ModuleData.Toggle = Tabs.Utility.Functions.NewModule({
        Name = '物品自动拾取器',
        Description = '自动拾取指定范围内的特定物品。',
        Icon = 'rbxassetid://7992268335',
        Flag = 'ItemCollectorModule_Integrated',
        Callback = function(self, enabled)
            ModuleData.IsEnabled = enabled
            if enabled then
                Functions.Notify('物品拾取器已启动！', 4)
                task.spawn(function()
                    repeat
                        task.wait(0.2)
                        if not ModuleData.IsEnabled then break end
                        local character = lplr.Character
                        local rootPart = character and character:FindFirstChild("HumanoidRootPart")
                        if not rootPart then continue end

                        local itemsToFind = {}
                        for item in string.gmatch(ModuleData.ItemNames, "[^,]+") do
                            table.insert(itemsToFind, string.gsub(item, "%s+", ""))
                        end
                        if #itemsToFind == 0 then continue end

                        for _, item in ipairs(ws:GetDescendants()) do
                            if table.find(itemsToFind, item.Name) and item:IsA("BasePart") then
                                if (rootPart.Position - item.Position).Magnitude <= ModuleData.CollectionRadius then
                                    if ModuleData.CollectionMethod == "传送至物品" then
                                        rootPart.CFrame = item.CFrame * CFrame.new(0, 3, 0)
                                    else
                                        local tween = tweenService:Create(item, TweenInfo.new(0.3), {CFrame = rootPart.CFrame})
                                        tween:Play()
                                    end
                                    if ModuleData.NotifyOnCollect then
                                        Functions.Notify("成功拾取: " .. item.Name, 2)
                                    end
                                    task.wait(0.1)
                                end
                            end
                        end
                    until not ModuleData.IsEnabled
                end)
            else
                Functions.Notify('物品拾取器已停止。', 3)
            end
        end
    })

    -- 为模块添加控件
    ModuleData.Toggle.Functions.Settings.TextBox({
        Name = '物品名称', Description = "输入要拾取的物品名，用逗号(,)隔开。", Default = ModuleData.ItemNames,
        PlaceHolderText = '例如: Cash,Coin,Gem', Flag = 'ItemCollector_Names_Integrated',
        Callback = function(_, text) ModuleData.ItemNames = text end
    })
    ModuleData.Toggle.Functions.Settings.Slider({
        Name = '拾取半径', Description = "设置拾取物品的最大距离。", Min = 10, Max = 500,
        Default = ModuleData.CollectionRadius, Decimals = 0, Flag = 'ItemCollector_Radius_Integrated',
        Callback = function(_, value) ModuleData.CollectionRadius = value end
    })
    ModuleData.Toggle.Functions.Settings.Dropdown({
        Name = '拾取方式', Description = "选择如何获取物品。", Default = ModuleData.CollectionMethod,
        Options = {'吸附物品', '传送至物品'}, SelectLimit = 1, Flag = 'ItemCollector_Method_Integrated',
        Callback = function(_, value) ModuleData.CollectionMethod = value end
    })
    ModuleData.Toggle.Functions.Settings.MiniToggle({
        Name = '拾取通知', Description = "在成功拾取物品时显示一条通知。", Default = ModuleData.NotifyOnCollect,
        Flag = 'ItemCollector_Notify_Integrated',
        Callback = function(_, enabled) ModuleData.NotifyOnCollect = enabled end
    })

    Functions.Notify('专属“物品拾取器”模块已成功加载！', 5)
end


-- 步骤 2: 主执行逻辑
-- 检查 Night UI 是否已经存在
if getgenv().Night and getgenv().Night.Loaded then
    -- 如果已经加载，直接创建我们的模块
    print("Night UI 已加载。正在创建自定义模块...")
    createOurCustomModule()
else
    -- 如果未加载，则先加载 Night UI
    print("Night UI 未被加载。正在执行加载器...")
    
    -- 使用 pcall 来安全地执行加载，防止因网络问题等导致整个脚本失败
    local success, err = pcall(function()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/null-wtf/Night/refs/heads/main/Night/Loader.luau"))()
    end)

    if success then
        print("Night UI 加载器已执行。正在等待其完全初始化...")
        
        -- 持续等待，直到 Night 环境完全准备就绪
        repeat task.wait() until getgenv().Night and getgenv().Night.Loaded
        
        print("Night UI 初始化完成。现在创建我们的自定义模块...")
        createOurCustomModule()
    else
        -- 如果加载失败，在控制台输出错误信息
        warn("加载 Night UI 时发生错误: ", err)
    end
end
